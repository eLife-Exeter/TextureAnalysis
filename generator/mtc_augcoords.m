function [augcoords,aug_opts_used]=mtc_augcoords(cgs_struct,mtcs,dict,aug_opts)
%
% [augcoords,aug_opts_used]=mtc_augcoords(cgs_struct,mtcs,dict,aug_opts) attempts to augment a subset of 
% 10 coordinates into a full set  of coords so that a 2x2 maxent texture can be generated
%
% cgs_struct: coordinate group array as a structure.
%   the defined fields must all be names in mtcs.coord_groups{*}.names
% mtcs:  structure for multiple-gray-level coordinates, generated by mtc_define,
%   must be passed; best if mtcs.counts is added mtcs.counts=mtc_countparams(mtcs);
%   otherwise this is done here
% dict:  dictionary of binary correlation names, generated by btc_define;
%    btc_define called if this field is empty or absent
% aug_opts:  a field of options
%   aug_opts.ifstd: 1 if dict is the standard one (saves recomputing)
%   aug_opts.nocheck: 1 if not to check normalization
%   aug_opts.iflog: 1 to log
%   aug_opts.tol_*: tolerance for matches, negative probabilities, Pickard (see mtc_defopts)
%   aug_opts.me_opts: options passed to mtc_cgsstruct2cgs_me
%   aug_opts.mtc_opts:  if non-empty, options to override defaults in mtc_defopts
%
% augcoords.aug_opts: options used
% augcoords.dict: dictionary used
% augcoords.method{:}: a cell array of methods used
%    augcoords.method{:}.name={Pickard | DiagMRF | NoPickTT | NoPickBT}
%      Pickard:  Markov propagation in 2x2 block (most rules)
%      DiagMRF:  Markov propagation in checkerboard-interleaved diagonal sublattices (both diagonal betas)
%      NoPickTT: Markov propagation in 2x2 block, followed by Metropolis
%        for thetas overlapping on an edge, since Markov propagation induces next-nearest-neighbor correls
%      NoPickBT: Markov propagation in a T, followed by Metropolis for theta and beta coming from angle,
%        T-propagation induces beta*theta of the opposite theta, and theta*beta^2 across the top of the T
%    Pickard variant 1 must be generated from NW(A) to SE(D); flankers of A and D pixels are conditionally indep of A and D
%    Pickard variant 2 must be generated from NE(B) to SW C); flankers of B and C pixels are conditionally indep of B and C.
% Note that genmrfmg only generates from upper NW (upper left) to SE (lower right)
%  aug_opts_used:  options used (omitted optoins added by mtc_defopts)
%
% A difference in behavior c/w btc_augcoords:  if specified cgs values lead to coordinates out of range, then 
%   the methods field will be empty
%
% Policies for creating the coordinates are as in btc_augocoords
%
%  Note that any number of constraints within a btc-type (letcode) can be
%  specified, and it only counts as a single "constraint" -- any
%  unspecified types within a letter code should default to their unbiased
%  values
%
%    See also: MTC_PLANE_TEST, MTC_PROBS2CGS, MTC_DEFINE, BTC_AUGCOORDS, BTC_DEFINE,
%    MTC_CGSSTRUCT2CGS, MTC_GETCORRS_P2X2, OUTPROD, MTC_COUNTPARAMS, MTC_CGSSTRUCT2CGS_ME,
%    MTC_BC_ME_TRYOUT, MTC_BD_ME_TRYOUT, MTC_DEFOPTS, MTC_CGSSTRUCT_MERGE,  MTC_CGSSTRUCT_RENAME, MTC_CGSSTRUCT_RMCLASS,
%    MTC_CGSSTRUCT_REMOVE, OUTPROD_CONTRACT, MTC_SELECTMETHS, FLFS_DEFINE, FLFS_BC_FINDP.
%
if (nargin<3)
    dict=btc_define;
end
if (nargin<4)
    aug_opts=[];
end
if (isempty(dict))
    dict=btc_define;
    aug_opts.ifstd=1;
end
aug_opts=filldefault(aug_opts,'ifstd',0);
aug_opts=filldefault(aug_opts,'nocheck',0);
aug_opts=filldefault(aug_opts,'me_opts',[]);
aug_opts=filldefault(aug_opts,'mtc_opts',[]);
%anything explicitly supplied in aug_opts takes priority, then aug_opts.mtc_opts, then mtc_defopts
mtc_opts=mtc_defopts(aug_opts.mtc_opts);
aug_opts=filldefault(aug_opts,'iflog',mtc_opts.iflog);
aug_opts=filldefault(aug_opts,'tol_match',mtc_opts.tol_match);
aug_opts=filldefault(aug_opts,'tol_nonneg',mtc_opts.tol_nonneg);
aug_opts=filldefault(aug_opts,'tol_Pickard',mtc_opts.tol_Pickard);
aug_opts=filldefault(aug_opts,'augcoords_bc_zshort',mtc_opts.augcoords_bc_zshort);
aug_opts=filldefault(aug_opts,'augcoords_bc_mshort',mtc_opts.augcoords_bc_mshort);
aug_opts=filldefault(aug_opts,'augcoords_bd_zshort',mtc_opts.augcoords_bd_zshort);
aug_opts=filldefault(aug_opts,'flfs',[]);
aug_opts=filldefault(aug_opts,'flfs_configs',[]);
aug_opts=filldefault(aug_opts,'flfs_factors',[]);
aug_opts_used=aug_opts;
%
if (aug_opts.ifstd==0)
    dict_std=btc_define; %for when we need a standard dictionary
else
    dict_std=dict;
end
augcoords=[];
augcoord.aug_opts=aug_opts;
augcoords.dict=dict;
%
ng=mtcs.ng;
if ~isfield(mtcs,'counts')
    mtcs.counts=mtc_countparams(mtcs);
end
method=[];
%
%this determines the kinds of coordinates as projected into btc_space
%this is useful for determining whether it is a Pickard set or not,
%and reduction via rotational and mirror symmetry
%
% note that we could have two coordinates of the same "kind", i.e.,
% two b-coordinates, specifying a mixture of probs for AB ; this should behave the same as a single 'b'
%
[cgs_parsed,letcodes,exptname,nspec]=mtc_augcoords_setup(cgs_struct,dict,mtcs);
n4=cgs_parsed.nkinds(4);
%create coordinate group structure for unbiased point
cgs_struct_unbiased=mtc_cgsstruct_fill([],mtcs);
cgs_unbiased=mtc_cgsstruct2cgs(cgs_struct_unbiased,mtcs);
if (aug_opts.iflog)
    disp('cgs_parsed')
    disp(cgs_parsed)
    disp('cgs_parsed.coorkinds')
    disp(cgs_parsed.coorkinds)
    disp('cgs_parsed.cgs_byletcode')
    disp(cgs_parsed.cgs_byletcode)
end
%
if (nspec==0) %null case
    method=mtc_augcoords_fillmeth(cgs_unbiased,[1 2]); %both Pickard branches
end
if (nspec==1) %one-variable cases
    [cgs_aug,vnums]=mtc_augcoords_1var(cgs_parsed,exptname,dict,mtcs,aug_opts);
    if ~isempty(cgs_aug)
        method=mtc_augcoords_fillmeth(cgs_aug,vnums);
    else
        method=mtc_augcoords_fillmeth([],[],[]);
    end
end
if (nspec==2) %two-variable cases
    if (n4==1)
        %if alpha is present, find the augmented direction for alpha=0, and then set alpha
        [cgs_parsed_r,letcodes_r,exptname_r]=mtc_augcoords_setup(cgs_struct,dict,mtcs,'ABCD');
        [cgs_aug,vnums]=mtc_augcoords_1var(cgs_parsed_r,exptname_r,dict,mtcs,aug_opts);
        if ~isempty(cgs_aug)
            %insert the alpha fields into cgs_aug here
            [cgs_ABCD,list_ABCD]=mtc_cgsstruct2cgs(cgs_parsed.cgs_byletcode.a,mtcs);
            cgs_aug(list_ABCD,:)=cgs_ABCD(list_ABCD,:);
            mname='Pickard';
            [cgs_aug,vnums,mname]=mtc_augcoords_nonneg(cgs_aug,vnums,mname,mtcs,aug_opts);
            method=mtc_augcoords_fillmeth(cgs_aug,vnums,mname);
        else
            method=mtc_augcoords_fillmeth([],[],[]);
        end
    else
        %two variables, both not alpha
        % for example, theta, gamma:  betas are gamma^2, other thetas are gamma^3 and alpha=gamma*theta
        [cgs_aug,vnums,mname,extend]=mtc_augcoords_2var(cgs_parsed,exptname,dict,mtcs,aug_opts);
        if ~isempty(cgs_aug)
            [cgs_aug,vnums,mname]=mtc_augcoords_nonneg(cgs_aug,vnums,mname,mtcs,aug_opts);
            method=mtc_augcoords_fillmeth(cgs_aug,vnums,mname);
        else
            method=mtc_augcoords_fillmeth([],[],[]);
        end
    end
end
%three- and four-variable cases not checked
if (nspec==3) %three-variable cases
    if (n4==1)
        %if alpha is present, find the augmented direction when alpha=0, and then set alpha
        [cgs_parsed_r,letcodes_r,exptname_r]=mtc_augcoords_setup(cgs_struct,dict,mtcs,'ABCD');
        [cgs_aug,vnums,mname]=mtc_augcoords_2var(cgs_parsed_r,exptname_r,dict,mtcs,aug_opts);
        %will have to redo what is below to allow for cgs_aug being a structure,
        %and the multiple variants possible, for example, with bc
        %
        %insert the alpha fields into cgs_aug here
        [cgs_ABCD,list_ABCD]=mtc_cgsstruct2cgs(cgs_parsed.cgs_byletcode.a,mtcs);
        cgs_aug(list_ABCD,:)=cgs_ABCD(list_ABCD,:);
        p2x2=mtc_cgst2probs(cgs_aug,mtcs);
        if min(p2x2(:))<(-aug_opts.tol_nonneg)
            method=mtc_augcoords_fillmeth([],[],[]);
        else
            method=mtc_augcoords_fillmeth(cgs_aug,vnums,mname);
        end      
    else
        %no algorithms at present
        method=mtc_augcoords_fillmeth([],[],[]);
    end
end
%
% Common completion
%
% If cgs_struct exists but not p2x2, make the probability structure
for im=1:length(method)
    if (isfield(method{im},'cgs_aug') & ~isfield(method{im},'p2x2'))
        p2x2=mtc_cgst2probs(method{im}.cgs_aug,mtcs);
        if min(p2x2(:))>-aug_opts.tol_nonneg
            p2x2=max(p2x2,0);
        end
        method{im}.p2x2=p2x2;
    end
    if (isfield(method{im},'cgs_aug') & ~isfield(method{im},'cgsaug_struct'))
        method{im}.cgsaug_struct=mtc_cgs2cgsstruct(method{im}.cgs_aug,mtcs);
    end
    %clean unbiased coords but include all input coords even if unbiased
    if isfield(method{im},'cgsaug_struct')
        clean_struct=mtc_cgsstruct_clean(method{im}.cgsaug_struct,mtcs,aug_opts);
        cgnames=fieldnames(cgs_struct);
        for icg=1:length(cgnames)
            if ~isfield(clean_struct,cgnames{icg})
                clean_struct.(cgnames{icg})=cgs_struct_unbiased.(cgnames{icg});
            end
        end
        method{im}.cgsaug_clean_struct=clean_struct;
    end
end
% also check p-values, normalization, and, if relevant, Pickard conditions
for im=1:length(method)
    if (aug_opts.nocheck==0)
        gc=mtc_getcorrs_p2x2(method{im}.p2x2,setfield(aug_opts,'nowarn_getcorrs',1));
        if (min(method{im}.p2x2(:))<-aug_opts.tol_nonneg)
            warning(sprintf('min(p2x2): %10.8f',min(method{im}.p2x2(:))));
        end
    else
        gc=[];
        gc.entropy=0;  %entropy as 2x2 MRF
        gc.cig_conds=[]; %not computed
        gc.norm=1;
        gc.ok_probs=1;
        gc.ok_norm=1;
    end
    method{im}.entropy_mrf22=gc.entropy;  %entropy as 2x2 MRF
    method{im}.cig_conds=gc.cig_conds;
    method{im}.norm=gc.norm;
    method{im}.ok_probs=double(all(method{im}.p2x2(:)>=-aug_opts.tol_nonneg));
    method{im}.ok_norm=double(abs(gc.norm-1)<aug_opts.tol_nonneg);
    mcorrs=method{im}.cgs_aug;
    %
    % create a full name from original method name and variant label, 
    % and then shorten the name (so that a name like 'Pickard consensus' becomes 'Pickard')
    method{im}.fullname=cat(2,method{im}.name,' ',method{im}.variant_lab);
    blankpos=findstr(method{im}.name,' ');
    if length(blankpos)>0
        method{im}.name=method{im}.name(1:blankpos-1);
    end
    switch method{im}.name
        case 'Pickard'
            method{im}.entropy_mrf=method{im}.entropy_mrf22;
        case {'DiagMRF','DiagFLFS'} 
            %
            % set up the correlations and entropy on the diagonally-interleaved lattices
            %
            method{im}.cgs_aug_diag=extend.cgs_aug_diag{im};
            method{im}.cgsaug_struct_diag=mtc_cgs2cgsstruct(method{im}.cgs_aug_diag,mtcs);
            clean_struct_diag=mtc_cgsstruct_clean(method{im}.cgsaug_struct_diag,mtcs,aug_opts);
            cgnames=union(extend.names_AD,extend.names_BC);
            for icg=1:length(extend.names_AD)
                if ~isfield(clean_struct,cgnames{icg})
                    clean_struct.(cgnames{icg})=cgs_struct_unbiased.(cgnames{icg});
                end
            end
            method{im}.cgsaug_clean_struct_diag=clean_struct_diag;
            method{im}.p2x2_diag=mtc_cgst2probs(method{im}.cgs_aug_diag,mtcs); %name would diagp2x2 for two gray levels
            gc=mtc_getcorrs_p2x2(method{im}.p2x2_diag,setfield(aug_opts,'nowarn_getcorrs',1));
            method{im}.cig_conds_diag=gc.cig_conds;
            method{im}.entropy_mrf=gc.entropy; % this is the entropy per unit area: two independent lattices, each at half the density
            %special handling of DiagFLFS here
            if strcmp(method{im}.name,'DiagFLFS')
                method{im}.flfs=extend.flfs_data; %the parameters for the falling-leaves/falling-sticks construction
            end
  %         ng=2 version:
  %         method{im}.entropy_mrf=getfield(getcorrs_p2x2(method{im}.diagp2x2,setfield(aug_opts,'nowarn_getcorrs',1)),'entropy');
        case 'NoPickTT'
            method{im}.entropy_mrf=method{im}.entropy_mrf22; % an estimate is method{im}.entropy_mrf22 but it could be increased by Metropolis
        case 'NoPickBT'
            method{im}.entropy_mrf=method{im}.entropy_mrf22; % an estimate is method{im}.entropy_mrf22 but it could be changed by t-propagation and Metropolis
            %the 2x2 probs have to be OK, but also, the tee-probs, since
            %this propagates in a tee
            method{im}.ok_probs_2x2=method{im}.ok_probs;
            method{im}.ok_norm_2x2=method{im}.ok_norm;
            method{im}.cgsaug_struct_r=extend.cgsaug_struct_r;
            method{im}.tee_struct_r=extend.tee_struct_r;
            method{im}.tee_probs_r=extend.tee_probs_r; %name would be teeprobs for two gray lavels
            method{im}.ok_probs=double(all(method{im}.tee_probs_r(:)>=-aug_opts.tol_nonneg));
            method{im}.ok_norm=double(abs(sum(method{im}.tee_probs_r(:))-1)<aug_opts.tol_nonneg);
        case 'FLFS'
            method{im}.entropy_mrf=method{im}.entropy_mrf22; % an estimate is method{im}.entropy_mrf22 but it could be increased by Metropolis
            method{im}.flfs=extend.flfs_data; %the parameters for the falling-leaves/falling-sticks construction
    end
    %
    % if normalization is within tolerance, try to make it perfect
    if (method{im}.ok_probs==1) & (method{im}.ok_norm==1)
        p2x2=method{im}.p2x2;
        p2x2=max(p2x2,0);
        method{im}.p2x2=p2x2/sum(p2x2(:));
    end
    %
    if strcmp(method{im}.name,'Pickard') | strcmp(method{im}.name,'DiagMRF');
        if ~isempty(gc.cig_conds)
            method{im}.ok_Pickard=0;
            if strcmp(method{im}.variant_lab,'NWSE');
                method{im}.ok_Pickard=(max(max(abs(gc.cig_conds(:,[1 4]))))<aug_opts.tol_Pickard);
            end
            if strcmp(method{im}.variant_lab,'NESW');
                method{im}.ok_Pickard=(max(max(abs(gc.cig_conds(:,[2 3]))))<aug_opts.tol_Pickard);
            end
            if (method{im}.ok_Pickard==0)
                disp(sprintf('Pickard condition violated for exptname %s and variant %s',exptname,method{im}.variant_lab));
                disp(cgs_struct);
            end
        else
            method{im}.ok_Pickard=1;
            method{im}.ok_Pickard_message='Pickard conditions not checked as cig quantities not available.';
        end %cig_conds
    end
end
%
augcoords.method=method;
augcoords.dict=dict;
augcoords.aug_opts=aug_opts;
augcoords.cgs_parsed=cgs_parsed;
return

function method=mtc_augcoords_fillmeth(cgs_augs,vnums,mnames)
%
%fills in method values from correlations and Pickard branches
%note that "corrs" argument from btc_augcoords_fillmeth is replaced by cgs_augs
%
% cgs_augs and mnames can be cell arrays
%
if (nargin<=2)
    mnames='Pickard';   
end
method=[];
for im=1:length(vnums)
    if (iscell(cgs_augs))
        cgs_aug=cgs_augs{im};
    else
        cgs_aug=cgs_augs;
    end
    if (iscell(mnames))
        mname=mnames{im};
    else
        mname=mnames;
    end
    method{im}.name=mname;
    method{im}.cgs_aug=cgs_aug;
    method{im}.variant_num=vnums(im);
    mname_short=mname;
    blankpos=findstr(mname,' ');
    if length(blankpos)>0
        mname_short=mname_short(1:blankpos-1);
    end
    switch mname_short
    case {'Pickard','DiagMRF'}
            if (vnums(im)==1)
                method{im}.variant_lab='NWSE';
            end
            if (vnums(im)==2)
                method{im}.variant_lab='NESW';
            end
        case {'NoPickTT','NoPickBT'}
            method{im}.variant_lab=sprintf('rot%1.0f',method{im}.variant_num);
        otherwise
            method{im}.variant_lab='none';
    end
end
return

function [cgs_aug,vnums]=mtc_augcoords_1var(cgs_parsed,exptname,dict,mtcs,aug_opts)
%
ng=mtcs.ng;
%
cgs_struct=cgs_parsed.cgs_struct;
coorkinds=cgs_parsed.coorkinds;
exptname=cgs_parsed.exptname;
nkinds=cgs_parsed.nkinds;
btc_coordnum=cgs_parsed.btc_coordnum;
btc_coordposit=cgs_parsed.btc_coordposit;
cgs_byletcode=cgs_parsed.cgs_byletcode;
checks=cgs_parsed.checks;
%
%get a method for a singleton variable
name1=dict.ordernames{1};
name2=dict.ordernames{2};
name2hv=cat(2,dict.ordernames{2},'_hv');
name2di=cat(2,dict.ordernames{2},'_diag');
name3=dict.ordernames{3};
name4=dict.ordernames{4};
%
n1=length(getfield(coorkinds,name1));
n2hv=length(getfield(coorkinds,name2hv));
n2di=length(getfield(coorkinds,name2di));
n3=length(getfield(coorkinds,name3));
n4=length(getfield(coorkinds,name4));
%
% generalize multiplication into an outer product of the probabilities
%
% go from cgs to probs, and then marginalize.  This is trivial when ng is prime,
% but it also works for a general ng
%
%cgsstruct_each{q} is the cgs structure for the qth coordinate letter
%cgs_each{q} is the cgs array for the qth coordinate letter
%cgs_all is the cgs array for all coordinates together
%probs{q} is the set of probabilities for the qth coordinate letter
cgs_all=mtc_cgsstruct2cgs(cgs_struct,mtcs);
cgsstruct_each=cell(0);
cgs_each=cell(0);
probs=cell(0);
region=cell(0);
minprob=[];
mtscq=cell(0);
for q=1:length(exptname)
    cgsstruct_each{q}=cgs_byletcode.(exptname(q));
    for ic=1:length(checks{q})
        region{q}(ic,:)=mtcs.checkdef.(checks{q}(ic));
    end        
    mtcsq{q}=mtc_define(ng,gtc_define(region{q}));
    cgs_each{q}=mtc_cgsstruct2cgs(cgsstruct_each{q},mtcsq{q});
    [probs{q},minprob(q)]=mtc_cgst2probs(cgs_each{q},mtcsq{q});
    if minprob(q)>=-aug_opts.tol_nonneg
        probs{q}=probs{q}/sum(probs{q}(:));
    end
end
if min(minprob)<-aug_opts.tol_nonneg
    cgs_aug=[];
    vnums=[];
    return
end
%
if (n1==1) %gamma->gamma, gamma^2, gamma^3, gamma^4, as outer products
    pg=probs{1};
    p2x2=outprod(outprod(outprod(pg,pg),pg),pg);
    vnums=[1 2];
end
if (n2hv==1) %alpha gets two copies of a beta_hv
    pg=probs{1};
    p2x2=outprod(pg,pg);
    %not a general approach
    if (btc_coordposit(1)==2) %is the block vertical?
        p2x2=permute(p2x2,[1 3 2 4]); %coordinates play different roles
    end
    vnums=[1 2];
end
if (n2di==1) %alpha is 0 for specified beta_di
    pg=probs{1};
    pu=ones(ng,1)/ng;
    p2x2=outprod(outprod(pu,pg),pu); %works for BC:  pu is A, pg is BC, pu is D
    if (btc_coordposit(1)==3)
        p2x2=permute(p2x2,[2 1 4 3]); %coordinates play different roles
    end
    vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
end
if (n3==1)
    pg=probs{1};
    pu=ones(ng,1)/ng;
    switch btc_coordposit
        case 1 %ABC, 'v'
            p2x2=outprod(pg,pu); %works for ABC: pg is ABC, pu is D
        case 2 %ABD, 'w'
            p2x2=outprod(pg,pu); %works for ABC: pg is ABC, pu is D
            p2x2=permute(p2x2,[1 2 4 3]); %coordinates play different roles
        case 3 %ACD, 'u'
            p2x2=outprod(pu,pg); %works for BCD: pu ia A, pg is BCD
            p2x2=permute(p2x2,[2 1 3 4]); %coordinates play different roles
        case 4 %BCD, 't'
        p2x2=outprod(pu,pg); %works for BCD: pu ia A, pg is BCD
    end
    vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
end
if (n4==1) %alpha
    p2x2=probs{1};
    vnums=[1 2];
end
cgs_aug=mtc_probs2cgs(p2x2,mtcs);
return

function [cgs_aug,vnums,mname,extend]=mtc_augcoords_2var(cgs_parsed,exptname,dict,mtcs,aug_opts);
%get a method for a pair of variables, neither of which are alpha
%
extend=[]; %used to pass extra aguments to mtc_augcoords
%
ng=mtcs.ng;
nchecks=mtcs.nchecks;
%
cgs_struct=cgs_parsed.cgs_struct;
coorkinds=cgs_parsed.coorkinds;
exptname=cgs_parsed.exptname;
nkinds=cgs_parsed.nkinds;
btc_coordnum=cgs_parsed.btc_coordnum;
btc_coordposit=cgs_parsed.btc_coordposit;
cgs_byletcode=cgs_parsed.cgs_byletcode;
checks=cgs_parsed.checks;
%
name1=dict.ordernames{1};
name2=dict.ordernames{2};
name2hv=cat(2,dict.ordernames{2},'_hv');
name2di=cat(2,dict.ordernames{2},'_diag');
name3=dict.ordernames{3};
name4=dict.ordernames{4};
%
n1=length(getfield(coorkinds,name1));
n2hv=length(getfield(coorkinds,name2hv));
n2di=length(getfield(coorkinds,name2di));
n3=length(getfield(coorkinds,name3));
n4=length(getfield(coorkinds,name4));
%
% as in mtc_augcoords_1var, the idea is to generalize multiplication into an outer product of the probabilities
%
% We go from cgs to probs, and then marginalize.  This is trivial when ng is prime
% but it also works for a general ng
%
%cgsstruct_each{q} is the cgs structure for the qth coordinate letter
%cgs_each{q} is the cgs array for the qth coordinate letter
%cgs_all is the cgs array for all coordinates together
%probs{q} is the set of probabilities for the qth coordinate letter
cgs_all=mtc_cgsstruct2cgs(cgs_struct,mtcs);
cgsstruct_each=cell(0);
cgs_each=cell(0);
probs=cell(0);
region=cell(0);
minprob=[];
mtcsq=cell(0);
for q=1:length(exptname)
    cgsstruct_each{q}=cgs_byletcode.(exptname(q));
    for ic=1:length(checks{q})
        region{q}(ic,:)=mtcs.checkdef.(checks{q}(ic));
    end        
    mtcsq{q}=mtc_define(ng,gtc_define(region{q}));
    cgs_each{q}=mtc_cgsstruct2cgs(cgsstruct_each{q},mtcsq{q});
    [probs{q},minprob(q)]=mtc_cgst2probs(cgs_each{q},mtcsq{q});
    if minprob(q)>=-aug_opts.tol_nonneg
        probs{q}=max(probs{q},0);
        probs{q}=probs{q}/sum(probs{q}(:));
    end
end
if min(minprob)<-aug_opts.tol_nonneg
    cgs_aug=[];
    vnums=[];
    mname=[];
    return
end
%individual cases
if (n1==1) & (n2hv==1) %cgsstruct_each(1) is beta_hv, cgsstruct_each(2) is gamma -- parameters are for independent 1-d processes
    pg=probs{2};
    pgg=outprod(pg,pg);
    cgs_gg=mtc_probs2cgs(pgg,mtcsq{1});
    [cgs_beta_hv,list_beta_hv]=mtc_cgsstruct2cgs(cgsstruct_each{1},mtcsq{1});
    cgs_bg=cgs_gg;
    cgs_bg(list_beta_hv,:)=cgs_beta_hv(list_beta_hv,:);
    %convert cgs_bg to a prob, and do outer product
    p1x2_bg=mtc_cgst2probs(cgs_bg,mtcsq{1});
    p2x2=outprod(p1x2_bg,p1x2_bg);
    if (btc_coordposit(1)==2) %is the block vertical?
        p2x2=permute(p2x2,[1 3 2 4]); %coordinates play different roles
    end
    cgs_aug=mtc_probs2cgs(p2x2,mtcs);
    vnums=[1 2];
    mname='Pickard';
end
if (n1==1) & (n2di==1) %cgsstruct_each(1) is beta_di, cgsstruct_each(2) is gamma -- parameters are for independent 1-d processes
    pg=probs{2};
    pgg=outprod(pg,pg);
    cgs_gg=mtc_probs2cgs(pgg,mtcsq{1});
    [cgs_beta_di,list_beta_di]=mtc_cgsstruct2cgs(cgsstruct_each{1},mtcsq{1});
    cgs_dg=cgs_gg;
    cgs_dg(list_beta_di,:)=cgs_beta_di(list_beta_di,:);
    %convert cgs_dg to a prob, and do outer product
    p1x2_dg=mtc_cgst2probs(cgs_dg,mtcsq{1});
    p2x2=outprod(outprod(pg,p1x2_dg),pg);
    if (btc_coordposit(1)==3) %is the diagonal NESW?
        p2x2=permute(p2x2,[2 1 4 3]); %coordinates play different roles
    end
    cgs_aug=mtc_probs2cgs(p2x2,mtcs);
    vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
    mname='Pickard';
end
if (n2hv==2) %cgsstruct_each(1) is one beta_hv, cgsstruct_each(2) is the other
%     generalizes the btc procedure in which 
%        the beta-diags are the products of the beta-cards
%        the thetas are zero, and alpha=maxent for beta_h, beta_v, beta_diag=beta_h*beta_v
%        for binary textures, this is what is required for being Pickard in both directions
%        and is always possible
%
%     for ng>2, compatibility with Pickard in one direction (NWSE) need not imply
%        compatibility with Pickard in the other direction (NESW) -- but this is guaranteed
%        for single-direction biases (see graylevs_mtc.doc).
%
%     And even the betas are compatible with extensions that are Pickard in a single direction,
%        there may not be an extension that is compatible with Pickard in both directions
%
%   Not yet done:  mixture methods to deal with non-Pickard cases within the bc plane.  If bc
%   is non-Pickard, then no method is returned.
%
%   Possiblities include Metropolis mixtures and "falling leaves" followed
%   by Metropolis.  Metropolis mixtures should be able to make anything up to half-saturation 
%   on any two axes, by mixing two full-saturation images.  These strategies are needed for any pair
%   of incompatible b and c coords, i.e.,for which XY~=YX, where X and Y are the transitoin
%   matrices for AB and AC, respectively.
%
%   see mtc_bc_me_tryout.
%
    vnums=[];
    mname=cell(0);
    cgs_aug=cell(0);
    pb=probs{1};
    pc=probs{2};
    %see if we can take a shortcut, if either pb or pc is unbiased
    ifshort=0;
    if (aug_opts.augcoords_bc_zshort==1)
        if max(max(abs(pb-ones(ng,ng)/ng/ng)))<aug_opts.tol_match
            ifshort=2; %b-coord iz zero
            let_active='c';
        end
        if max(max(abs(pc-ones(ng,ng)/ng/ng)))<aug_opts.tol_match
            ifshort=1; %c-coord is zero (and possibly b)
            let_active='b';
        end
         if (aug_opts.iflog)
            disp(sprintf('mtc_augcoords bc:  ifshort=%2.0f',ifshort));
        end
    end
    if (ifshort>0) %ensure that we have the same methods as if there were no shortcut
        cgs_struct_short=cgs_byletcode.(let_active);
        [cgs_parsed_short,exptname_short]=mtc_augcoords_setup(cgs_struct_short,dict,mtcs);
        cgs_aug_1var=mtc_augcoords_1var(cgs_parsed_short,exptname_short,dict,mtcs,aug_opts);
        for im=1:4
            cgs_aug{im}=cgs_aug_1var;
            vnums(im)=1+mod(im,2); %vnums=[1 2 1 2];
            if (im<=2)
                mname{im}='Pickard Markov';
            else
                mname{im}='Pickard consensus';
            end
        end
    else
        im=0; %counts successful methods
        failpass={'FAIL','PASS'};
        pABD=cell(1,2);
        pACD=cell(1,2);
        pABCD=cell(1,2);
        cgsABCD_full=cell(1,2);
        cgsstructABCD_full=cell(1,2);
        cgsstructABCD_loworder=cell(1,2);
        cgsABCD_me=cell(1,2);
        %first look for extensions that are Pickard in one direction
        for idir=1:2 %try diagonals in each direction, idir=1 is AD diag, idir=2 for BC diag   
            if (idir==1)
                X=pb;
                Y=pc;
                diagname='AD';
            end
            if (idir==2) %BC diag -- flip L and R, but later flip back
                X=pb';
                Y=pc;
                diagname='BC';
            end
            comm=X*Y-Y*X;
            ifPickard(idir)=double(max(abs(comm(:)))<=aug_opts.tol_Pickard);
            if (aug_opts.iflog)
                disp(sprintf('mtc_augcoords bc: dir %1.0f (%s): %s for Pickard max commutator is %10.8f (  must be <= %10.8f)',...
                    idir,diagname,failpass{ifPickard(idir)+1},max(abs(comm(:))),aug_opts.tol_Pickard));
            end
            if ifPickard(idir)
                im=im+1;
                pABD{idir}=ng*outprod_contract(X,Y,[2;1]); %%the factor of ng is really 1/(1/ng), where ng=prob of any singleton
                pACD{idir}=ng*outprod_contract(Y,X,[2;1]);
                %
                pABDpACD=permute(outprod_contract(pABD{idir},pACD{idir},[1 3;1 3]),[2 1 4 3]);
                pAD=ng*X*Y;
                pABCD{idir}=zeros(ng,ng,ng,ng);
                for ia=1:ng
                    for id=1:ng
                        if pAD(ia,id)>0
                            pABCD{idir}(ia,:,:,id)=pABDpACD(ia,:,:,id)/pAD(ia,id);
                        end
                    end
                end
                if (idir==2)
                    pABCD{idir}=permute(pABCD{idir},[2 1 4 3]); %flip back
                end
                vnums(1,im)=3-idir; %AD diagonal is for Pickard NESW
                mname{im}='Pickard Markov';
                %
                %
                % this is maxent for the alphas, but could also determine maxent explicitly
                %
                cgsABCD_full{idir}=mtc_probs2cgs(pABCD{idir},mtcs); %this is always a feasible starting point
                cgsstructABCD_full{idir}=mtc_cgs2cgsstruct(cgsABCD_full{idir},mtcs);
                opts_me=aug_opts.me_opts;
                opts_me.cgshint_struct=cgsstructABCD_full{idir};
                if (aug_opts.augcoords_bc_mshort==1)
                    cgs_aug{im}=cgsABCD_full{idir}; %assume Markov probs are maxent (they should be!)
                else
                    %find the alphas that maximize the entropy
                    %maximize the entropy across high-order params
                    cgsstructABCD_loworder{idir}=mtc_cgsstruct_remove(cgsstructABCD_full{idir},mtcs.nchecks,mtcs,mtcs.counts);
                    [cgsABCD_me{idir},cgsABCD_loworder,cgs_list,opts_used_me]=...
                        mtc_cgsstruct2cgs_me(cgsstructABCD_loworder{idir},mtcs,opts_me);
                    cgs_aug{im}=cgsABCD_me{idir};
                    maxdiff_maxent=max(abs(cgsABCD_me{idir}(:)-cgsABCD_full{idir}(:)));
                    if (aug_opts.iflog==1) | (maxdiff_maxent>aug_opts.tol_match)
                        disp(sprintf('mtc_augcoords bc: dir %1.0f (%s): max diff betw Markov and maxent is %10.8f (should be  = %10.8f)',...
                            idir,diagname,maxdiff_maxent,0));
                    end
                end
            end %if Pickard
        end %idir
        if all(ifPickard)
            %code borrowed from mtc_bc_me_tryout
            %try to find a consensus that is Pickard in both directions
            %    remove BC, ABC, BCD fields from idir=1
            %    remove AD, ABD, ACD fields from idir=2
            % then merge
            %
            % if there is a mismatch, it is logged -- it should only affect fourth-order parameters,
            % which doesn't matter, since these are then determined by maxent rather than by consensus
            % **mtc_bc_me_tryout generates an error if the merging fails; this
            % does not.  Merging can fail if both the AB and AC specifications
            % are "off-axis".  See mtc_bc_me_tryout2.  But the approach here
            % will produce a correct texture in that case.
            %
            cgs_struct_con=[];
            structAD=mtc_cgsstruct_rmclass(cgsstructABCD_full{1},{'BC','ABC','BCD'},mtcs);
            structBC=mtc_cgsstruct_rmclass(cgsstructABCD_full{2},{'AD','ABD','ACD'},mtcs);
            [cgs_struct_con,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
                =mtc_cgsstruct_merge(structAD,structBC,setfield(aug_opts,'mismatch_action','keep_average'));
            if (aug_opts.iflog==1)
                disp(mergemsg_all);
            end
            if (merge_counts.n_mismatches>0)
                disp('mtc_augcoords bc:  Some mismatches in order-4 coordinates in forming consensus.');
                disp(cgs_struct);
                disp(mergemsg_warn);
            end
            cgs_struct_con_loworder=mtc_cgsstruct_remove(cgs_struct_con,mtcs.nchecks,mtcs,mtcs.counts);
            opts_con_me=opts_me;
            opts_con_me.cgshint_struct=cgs_struct_con;
            if (aug_opts.iflog==1)
                disp(sprintf('mtc_augcoords bc: formed consensus for AD and BC, now looking for feasible values'));
            end
            [cgs_con_me,cgs_con_loworder,cgs_con_list,opts_used_con_me]=...
                mtc_cgsstruct2cgs_me(cgs_struct_con_loworder,mtcs,opts_con_me);
            if ~isempty(cgs_con_me)
                for idir=1:2
                    im=im+1;
                    vnums(1,im)=3-idir; %AD diagonal is for Pickard NESW
                    mname{im}='Pickard consensus';
                    cgs_aug{im}=cgs_con_me;
                end
            end %merge_count.n_mismatches
            %cgs_struct_con
            %cgs_con_me
        end
    end %ifshort       
    %
    % falling-leaves/falling sticks mixture methods
    %
    if (aug_opts.iflog==1)
        disp('mtc_augcoords bc: in flfs section');
    end
    flfs=aug_opts.flfs;
    if isempty(flfs)
        flfs=flfs_define([],mtc_define(2));
        if (aug_opts.iflog==1)
            disp('mtc_augcoords bc: flfs computed.');
        end
    end
    flfs_configs=aug_opts.flfs_configs;
    if isempty(flfs_configs)
        flfs_configs=flfs_enumerate(flfs);
        if (aug_opts.iflog==1)
            disp('mtc_augcoords bc: flfs_configs computed.');
        end
    end
    flfs_factors=aug_opts.flfs_factors;
    if isempty(flfs_factors)
        flfs_factors=flfs_bc_factors(flfs_configs);
        if (aug_opts.iflog==1)
            disp('mtc_augcoords bc: flfs_factors computed.');
        end
    end
    %pb=probs{1};
    %pc=probs{2};
    bc_mix=zeros(1,2);
    unb2=1/(ng^2);
    for ibc=1:2
        p=probs{ibc};
        bc_mix(ibc)=max((unb2-p(:))/unb2); %bias of specified coords, as fraction of maximal bias possible, per mtc_augcoords
    end
    if max(bc_mix)>0
        [p_hv,bc,fzero_out,eivec]=flfs_bc_findp(bc_mix,flfs,flfs_configs,flfs_factors);
    else
        [p_hv,bc,fzero_out,eivec]=flfs_bc_findp([1 1],flfs,flfs_configs,flfs_factors); %special case at origin
    end
    weight.b=flfs_factors.b'*eivec;
    weight.c=flfs_factors.c'*eivec;
    weight.bb=flfs_factors.bb'*eivec;
    weight.cc=flfs_factors.cc'*eivec;
    %determine if an flfs construction is feasible -- is bc_mix always <= bc
    flfs_probs=cell(2,1);
    for ibc=1:2
        flfs_probs{ibc}=(probs{ibc}-unb2)/bc(ibc)+unb2; %make flfs_probs{ibc} more saturated than probs{ibc} by a factor of 1/ibc(bc)
    end
    %for the algorithm to work, saturations must be achivable, and 
    %the 2-block probs for rows and columns must all be nonnegative
    if_flfs_exist=all(...
        [all(bc_mix<=(bc+aug_opts.tol_nonneg)),...
        all(flfs_probs{1}(:)>=-aug_opts.tol_nonneg),...
        all(flfs_probs{2}(:)>=-aug_opts.tol_nonneg)]);
    if (aug_opts.iflog==1)
        disp(sprintf('mtc_augcoords bc: if_flfs_exist=%2.0f',if_flfs_exist));
        disp(sprintf('mtc_augcoords bc:    bc_mix: %13.10f %13.10f (saturation as fraction of max)',bc_mix));
        disp(sprintf('mtc_augcoords bc:        bc: %13.10f %13.10f (saturation needed to account for dilution of flfs algorithm)',bc));
        disp(sprintf('mtc_augcoords bc: bc-bc_mix: %13.10f %13.10f',bc-bc_mix));
        disp(sprintf('mtc_augcoords bc: p_hv: %10.8f',p_hv));
        disp(sprintf('mtc_augcoords bc: flfs min prob for Markov matrix for rows: %8.6f, for cols: %8.6f',...
            min(flfs_probs{1}(:)),min(flfs_probs{2}(:))));
        disp('mtc_augcoords bc: flfs eigenvector')
        disp(eivec(:)');
        disp('mtc_augcoords bc: flfs weights')
        disp(weight);
    end
    %
    % determine the parameters of the construction
    %
    % weight.b-weight.bb to mix flfs_probs{1} with unbiased for AB's in position AB and CD
    % weight.c-weight.cc to mix flfs_probs{2} with unbiased for AC's in position AC and BD
    % weight.bb to mix flfs_probs{1} tensor itself for the b-component of ABCD's
    % weight.cc to mix flfs_probs{2} tensor itself for the c-component of ABCD's
    qb=outprod(flfs_probs{1},unb2*ones(ng,ng));
    qbb=outprod(flfs_probs{1},flfs_probs{1});
    qc=permute(outprod(flfs_probs{2},unb2*ones(ng,ng)),[1 3 2 4]);
    qcc=permute(outprod(flfs_probs{2},flfs_probs{2}),[1 3 2 4]);
    qtot=(weight.b-weight.bb)*(qb+permute(qb,[3 4 1 2]))+weight.bb*qbb+...
        (weight.c-weight.cc)*(qc+permute(qc,[2 1 4 3]))+weight.cc*qcc;
%     disp('qb')
%     disp(mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(qb,mtcs),mtcs),mtcs));
%     disp('qbb')
%     disp(mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(qbb,mtcs),mtcs),mtcs));
%     disp('qc');
%     disp(mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(qc,mtcs),mtcs),mtcs));
%     disp('qcc');
%     disp(mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(qcc,mtcs),mtcs),mtcs));
%     disp('qtot');
%     disp(mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(qtot,mtcs),mtcs),mtcs));
%     disp('sum of qtot, should be 1')
%     disp(sum(qtot(:)));
    if (if_flfs_exist)
        im=im+1;
        vnums(1,im)=1; %no variants
        mname{im}='FLFS';
        cgs_aug{im}=mtc_probs2cgs(qtot,mtcs); %the augmented coords
        extend.flfs_data.flfs=flfs;
        extend.flfs_data.flfs_configs=flfs_configs;
        extend.flfs_data.flfs_factors=flfs_factors;
        extend.flfs_data.flfs_eivec=eivec;
        extend.flfs_data.flfs_weight=weight;
        extend.flfs_data.flfs_p_hv=p_hv; %the relative probabilities of the rows and columns
        extend.flfs_data.flfs_probs=flfs_probs; %the ng x ng matrices to make the rows and columns of the flfs construction 
    end
end
%
if (n2hv==1) & (n2di==1) %cgsstruct_each(1) is beta_hv, cgsstruct_each(2) is beta_di
    %assume bd plane, make upper and lower triangles and then set beta_h to zero,
    %then put together to make the p2x2, then choose alpha to maximize entropy
    %
    %  see mtc_bd_me_tryout
    %
    strat_labels={'ZeroTheta','MarkovTheta'}; %zerotheta is lower entropy but consistent with btc
    %
    %see if we can take a shortcut, if either pb or pd is unbiased
    %
    ifshort=0;
    if (aug_opts.augcoords_bd_zshort==1)
        if max(max(abs(probs{1}-ones(ng,ng)/ng/ng)))<aug_opts.tol_match
            ifshort=2; %b-coord or c-coord is zero
            let_active=cgs_parsed.exptname(2); %d or e
        end
        if max(max(abs(probs{2}-ones(ng,ng)/ng/ng)))<aug_opts.tol_match
            ifshort=1; %d-coord or e-coord is zero (and possibly b or c)
            let_active=cgs_parsed.exptname(1); %b or c
        end
        if (aug_opts.iflog)
            disp(sprintf('mtc_augcoords bd:  ifshort=%2.0f',ifshort));
        end
    end
    %
    if (ifshort>0)  %ensure that we have the same methods as if there were no shortcut
        cgs_struct_short=cgs_byletcode.(let_active);
        [cgs_parsed_short,exptname_short]=mtc_augcoords_setup(cgs_struct_short,dict,mtcs);
        cgs_aug=mtc_augcoords_1var(cgs_parsed_short,exptname_short,dict,mtcs,aug_opts);
        vnums_short=find(dict.inpickard(:,btc_coordnum(2))==1);
        for im=1:2
            vnums(1,im)=vnums_short;
            mname{im}=cat(2,'Pickard ',strat_labels{im});
        end
    else
        m.ABD=mtc_define(ng,gtc_define([0 0;0 1;1 1]));
        m.ACD=mtc_define(ng,gtc_define([0 0;1 0;1 1]));
        probs_AB=probs{1}; %analogous to pb
        probs_AD=probs{2}; %analogous to pd
        % transform if necessary so that the first check in probs_AB
        % coincides with the first check in probs_AD
        if (btc_coordposit(1)==1) & (btc_coordposit(2)==4) %be-plane
            probs_AB=probs_AB'; %b: AB, e: BC so b needs to be switched
        end
        if (btc_coordposit(1)==2) & (btc_coordposit(2)==4) %ce-plane
            probs_AB=probs_AB'; % c: AC, e: BC, so b and c need to be switched
            probs_AD=probs_AD';
        end
        %
        %calculate ABD structure for Markov chain for AB and AD
        probs_ABD=ng*permute(outprod_contract(probs_AB,probs_AD,[1;1]),[2 1 3]); %the factor of ng is really 1/(1/ng), where ng=prob of any singleton
        %calculate ACD structure for Markov chain for CD=AB and AD
        probs_ACD=ng*permute(outprod_contract(probs_AD,probs_AB,[2;2]),[1 3 2]);
        %
        cgsvals_ABD=mtc_probs2cgs(probs_ABD,m.ABD);
        cgs_struct_ABD=mtc_cgs2cgsstruct(cgsvals_ABD,m.ABD);
        cgsvals_ACD=mtc_probs2cgs(probs_ACD,m.ACD);
        cgs_struct_ACD=mtc_cgs2cgsstruct(cgsvals_ACD,m.ACD);
        %
        % now set the beta-vertical to zero
        % specific to bd plane:  now create structures with the induced
        % beta-vertical set to zero, so that Pickard conditions will hold
        %
        % strategy 2: zero the vertical betas
        cgs_struct_ABDz{2}=mtc_cgsstruct_rmclass(cgs_struct_ABD,'BD',m.ABD);
        cgs_struct_ACDz{2}=mtc_cgsstruct_rmclass(cgs_struct_ACD,'AC',m.ACD);
        % strategy 1: zero the vertical betas and the induced thetas
        cgs_struct_ABDz{1}=mtc_cgsstruct_rmclass(cgs_struct_ABDz{2},'ABD',m.ABD);
        cgs_struct_ACDz{1}=mtc_cgsstruct_rmclass(cgs_struct_ACDz{2},'ACD',m.ACD);
        %
        im=0;
        vnums=[];
        mname=[];
        %
        for is=1:2
            cgsvals_ABDz{is}=mtc_cgsstruct2cgs(cgs_struct_ABDz{is},m.ABD);
            probs_ABDz{is}=mtc_cgst2probs(cgsvals_ABDz{is},m.ABD);
            cgsvals_ACDz{is}=mtc_cgsstruct2cgs(cgs_struct_ACDz{is},m.ACD);
            probs_ACDz{is}=mtc_cgst2probs(cgsvals_ACDz{is},m.ACD);
        end
        %
        if (aug_opts.iflog==1)
            disp(sprintf(' ABD     triangle     via Markov:  normalization %8.6f min prob %8.6f',sum(probs_ABD(:)),min(probs_ABD(:))));
            disp(sprintf(' ABDz{1} triangle BD, ABD zeroed:  normalization %8.6f min prob %8.6f',sum(probs_ABDz{1}(:)),min(probs_ABDz{1}(:))));
            disp(sprintf(' ABDz{2} triangle BD      zeroed:  normalization %8.6f min prob %8.6f',sum(probs_ABDz{2}(:)),min(probs_ABDz{2}(:))));
            disp(sprintf(' ACD     triangle     via Markov:  normalization %8.6f min prob %8.6f',sum(probs_ACD(:)),min(probs_ACD(:))));
            disp(sprintf(' ACDz{1} triangle AC, ACD zeroed:  normalization %8.6f min prob %8.6f',sum(probs_ACDz{1}(:)),min(probs_ACDz{1}(:))));
            disp(sprintf(' ACDz{2} triangle AC      zeroed:  normalization %8.6f min prob %8.6f',sum(probs_ACDz{2}(:)),min(probs_ACDz{2}(:))));
        end
        %
        % Put the two zeroed triangles together.
        % Do this by merging coordinates or via Markov.
        % Merging coordinates necessarily guarantees Pickard, Markov does not.
        % Merging coordinates need not yield non-negative probabilites, but Markov must.
        %
        %create a 2x2 structure by merging ABDz and ACDz
        % logic is different than for the merge in the bc case because here,
        % the structures have only partially overlapping fields
        %
        im=0;
        cgs_aug=[];
        vnums=[];
        mname=[];
        for is=1:2
            strat_label=strat_labels{is};
            cgs_struct_ABDzR=mtc_cgsstruct_rename(cgs_struct_ABDz{is},m.ABD,mtcs);
            cgs_struct_ACDzR=mtc_cgsstruct_rename(cgs_struct_ACDz{is},m.ACD,mtcs);
             [cgs_struct_ABDz_ACDz,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
                 =mtc_cgsstruct_merge(cgs_struct_ABDzR,cgs_struct_ACDzR,setfield(aug_opts,'mismatch_action','error'));
            if (aug_opts.iflog==1)
                disp(mergemsg_all);
            end
            cgsvals_ABDz_ACDz=mtc_cgsstruct2cgs(cgs_struct_ABDz_ACDz,mtcs);
            probs_ABDz_ACDz=mtc_cgst2probs(cgsvals_ABDz_ACDz,mtcs);
            corrs_ABDz_ACDz=mtc_getcorrs_p2x2(probs_ABDz_ACDz,setfield(aug_opts,'nowarn_getcorrs',1));
            if (aug_opts.iflog)
                disp(sprintf(' strategy: %s',strat_label));
                disp(sprintf(' ABCD from ABDz and ACDz via coords:  normalization %8.6f min prob %8.6f, cig conds max abs %8.6f %8.6f %8.6f %8.6f',...
                    sum(probs_ABDz_ACDz(:)),min(probs_ABDz_ACDz(:)),max(abs(corrs_ABDz_ACDz.cig_conds),[],1)));
            end
            z_probs_OK=double(min(probs_ABDz_ACDz(:))>-aug_opts.tol_nonneg);
            z_pickard_OK=double(max(max(corrs_ABDz_ACDz.cig_conds(:,[1 4])))<aug_opts.tol_Pickard);
            %
            %create a probability matrix by Markov combination of the triangles made by zeroing pBD, pAC
            %
            pABDpACD=permute(outprod_contract(probs_ABDz{is},probs_ACDz{is},[1 3;1 3]),[2 1 4 3]);
            probs_ABDz_ACDz_M=zeros(ng,ng,ng,ng);
            for ia=1:ng
                for id=1:ng
                    if probs_AD(ia,id)>0
                        probs_ABDz_ACDz_M(ia,:,:,id)=pABDpACD(ia,:,:,id)/probs_AD(ia,id);
                    end
                end
            end
            %
            cgsvals_ABDz_ACDz_M=mtc_probs2cgs(probs_ABDz_ACDz_M,mtcs);
            cgs_struct_ABDz_ACDz_M=mtc_cgs2cgsstruct(cgsvals_ABDz_ACDz_M,mtcs);
            corrs_ABDz_ACDz_M=mtc_getcorrs_p2x2(probs_ABDz_ACDz_M,setfield(aug_opts,'nowarn_getcorrs',1));
            %
            if (aug_opts.iflog)
                disp(sprintf(' ABCD from ABDz and ACDz via Markov:  normalization %8.6f min prob %8.6f, cig conds max abs %8.6f %8.6f %8.6f %8.6f',...
                    sum(probs_ABDz_ACDz_M(:)),min(probs_ABDz_ACDz_M(:)),max(abs(corrs_ABDz_ACDz_M.cig_conds),[],1)));
                disp(sprintf(' maximum difference between coordinate-merge and Markov probabilities: %8.6f',...
                    max(abs(probs_ABDz_ACDz(:)-probs_ABDz_ACDz_M(:)))));
            end
            zM_probs_OK=double(min(probs_ABDz_ACDz_M(:))>=-aug_opts.tol_nonneg);
            zM_pickard_OK=double(max(max(corrs_ABDz_ACDz_M.cig_conds(:,[1 4])))<aug_opts.tol_Pickard);
            %
            % find the maxent high-order quantities, using the Markov fourth-orders as hint
            %
            cgs_struct_con=cgs_struct_ABDz_ACDz;
            if (aug_opts.iflog)
                disp(sprintf(' finding maxent for coord-merge (ABDz_ABCz) probs, if_pickard=%1.0f',z_pickard_OK));
            end
            cgs_struct_loworder=mtc_cgsstruct_remove(cgs_struct_con,mtcs.nchecks,mtcs,mtcs.counts);
            %form a structure with all coordinate groups *from the Markov construction* for the hint
            cgshint_struct=mtc_cgsstruct_remove(cgs_struct_ABDz_ACDz_M,[1:mtcs.nchecks-1],mtcs,mtcs.counts);
            %maximize the entropy across high-order params
            opts_me=aug_opts.me_opts;
            opts_me.cgshint_struct=cgshint_struct;
            [cgs_vals_maxentropy,cgs_vals_loworder,cgs_list,opts_used_me]=mtc_cgsstruct2cgs_me(cgs_struct_loworder,mtcs,opts_me);
            if ~isempty(cgs_vals_maxentropy)
                found_me=1;
                cgs_struct_con_me=mtc_cgs2cgsstruct(cgs_vals_maxentropy,mtcs);
                p_con_me=mtc_cgst2probs(cgs_vals_maxentropy,mtcs);
            else
                found_me=0;
                cgs_struct_con_me=[];
                p_con_me=[];
            end
            cgs_aug_me=cgs_vals_maxentropy;
            %
            %at this point, have to flip coords around if cd, be, or ce.
            %
            if ((btc_coordposit(1)==2) | (btc_coordposit(2)==4)) & (found_me==1)
                p2x2=mtc_cgst2probs(cgs_aug_me,mtcs);
                %up to here, A is the join, B is only in beta-horiz, C is unused, D is only in beta-diag, 
                if (btc_coordposit(1)==2) & (btc_coordposit(2)==3) %cd-plane, i.e., AC with AD
                    p2x2=permute(p2x2,[1 3 2 4]); %C takes the role of B
                end
                if (btc_coordposit(1)==1) & (btc_coordposit(2)==4) %be-plane, i.e., AB with BC
                    p2x2=permute(p2x2,[2 1 4 3]); %exchange A with B, exchange C with D
                end
                if (btc_coordposit(1)==2) & (btc_coordposit(2)==4) %ce-plane, i.e., AC with BC
                    p2x2=permute(p2x2,[2 4 1 3]); %A takes the role of B, B takes the role of D, C takes the role of A, D takes the role of C
                end
                cgs_aug_me=mtc_probs2cgs(p2x2,mtcs);
            end
            if (found_me==1)
                im=im+1;               
                vnums(1,im)=find(dict.inpickard(:,btc_coordnum(2))==1);
                cgs_aug{im}=cgs_aug_me;
                mname{im}=cat(2,'Pickard ',strat_label);
            end
        end %is
    end %ifshort
end
%
if (n2di==2) %cgsstruct_each(1) is one beta_di, cgsstruct_each(2) is the other; do this by Pickard on sublattices
%     corrs=setfield(corrs,name2,{btc_coordposit(1)},cgsstruct_each(1)); %one specified beta_di
%     corrs=setfield(corrs,name2,{btc_coordposit(2)},cgsstruct_each(2)); %the other specified beta_di
%     corrs=setfield(corrs,name4,cgsstruct_each(1)*cgsstruct_each(2));         %independent sublattices
%
% work recursively:
% [cgs_parsed,letcodes,exptname,nspec]=mtc_augcoords_setup(cgs_struct,dict,mtcs);
% [cgs_aug,vnums,mname]=mtc_augcoords_2var(cgs_parsed,exptname,dict,mtcs,aug_opts);
    %modify the AD fields to AC (or BD), modify the BC fields to AB
    cgs_struct_AD=cgs_parsed.cgs_byletcode.d;
    cgs_struct_BC=mtc_cgsstruct_reverse(cgs_parsed.cgs_byletcode.e,mtcsq{2}); %new horizontal direction is reverse of orig BC (see btc_dimrf)
    cgs_struct_diag=[];
    names_AD=fieldnames(cgs_struct_AD);
    names_BC=fieldnames(cgs_struct_BC);
    extend.names_AD=names_AD;
    extend.names_BC=names_BC;
    for ifield=1:length(names_AD)
        fn=names_AD{ifield};
        newname=strrep(fn,'AD_','AC_');
        cgs_struct_diag.(newname)=cgs_struct_AD.(fn);
    end
    for ifield=1:length(names_BC)
        fn=names_BC{ifield};
        newname=strrep(fn,'BC_','AB_');
        cgs_struct_diag.(newname)=cgs_struct_BC.(fn);
    end
    if (aug_opts.iflog==1)
        disp('original specifier in de plane:')
        disp(cgs_parsed.cgs_struct);
        disp('structure generated for analysis in bc plane:');
        disp(cgs_struct_diag);
    end
    % cgs_aug_diag is the augmented coordinates on the sub-array;
    % compute the augmented coords on the nearest-neighbor 2x2
    % it is the same for each method, as the 2x2 subarrays are independent
    probs_AD=mtc_cgst2probs(mtc_cgsstruct2cgs(cgs_parsed.cgs_byletcode.d,mtcs),mtcs);
    probs_BC=mtc_cgst2probs(mtc_cgsstruct2cgs(cgs_parsed.cgs_byletcode.e,mtcs),mtcs);
    probs_AD_1x2=squeeze(sum(sum(probs_AD,2),3));
    probs_BC_1x2=squeeze(sum(sum(probs_BC,1),4));
    probs_ADBC=outprod(probs_AD_1x2,probs_BC_1x2);
    probs_ABCD=permute(probs_ADBC,[1 3 4 2]);
    cgsaug_2x2=mtc_probs2cgs(probs_ABCD,mtcs);
    %cgsstruct_aug=mtc_cgs2cgsstruct(cgs_aug,mtcs); %useful for debugging but not needed for production
    %
    [cgs_parsed_diag,letcodes_diag,exptname_diag,nspec_diag]=mtc_augcoords_setup(cgs_struct_diag,dict,mtcs);
    [cgs_aug_diag,vnums_diag,mname_diag,extend_diag]=mtc_augcoords_2var(cgs_parsed_diag,exptname_diag,dict,mtcs,aug_opts);
    if iscell(cgs_aug_diag)
        extend.cgs_aug_diag=cgs_aug_diag;
    else
        for imeth=1:length(mname_diag)
            extend.cgs_aug_diag{imeth}=cgs_aug_diag;
        end
    end
    if isfield(extend_diag,'flfs_data')
        extend.flfs_data=extend_diag.flfs_data;
    end
    if isempty(cgs_aug_diag)
        cgs_aug=[];
        vnums=[];
        mname=[];
    else
        for imeth=1:length(mname_diag)
            cgs_aug{imeth}=cgsaug_2x2;
            mname{imeth}=cat(2,'DiagMRF ',mname_diag{imeth});
            mname{imeth}=strrep(mname{imeth},'DiagMRF FLFS','DiagFLFS'); %FLFS on diagonal is a special case
        end
        vnums=vnums_diag;
    end
end
%
if (n1==1) & (n3==1) %cgsstruct_each(1) is theta, cgsstruct_each(2) is gamma
    pu=probs{2};
    pggg=outprod(outprod(pu,pu),pu);
    cgs_ggg=mtc_probs2cgs(pggg,mtcsq{1});
    [cgs_theta,list_theta]=mtc_cgsstruct2cgs(cgsstruct_each{1},mtcsq{1});
    cgs_tg=cgs_ggg;
    cgs_tg(list_theta,:)=cgs_theta(list_theta,:);
    %convert cgs_bg to a prob, and do outer product
    ptg=mtc_cgst2probs(cgs_tg,mtcsq{1});
    switch btc_coordposit(1)
        case 1 %ABC, 'v'
            p2x2=outprod(ptg,pu); %works for ABC: pg is ABC, pu is D
        case 2 %ABD, 'w'
            p2x2=outprod(ptg,pu); %works for ABC: pg is ABC, pu is D
            p2x2=permute(p2x2,[1 2 4 3]); %coordinates play different roles
        case 3 %ACD, 'u'
            p2x2=outprod(pu,ptg); %works for BCD: pu ia A, pg is BCD
            p2x2=permute(p2x2,[2 1 3 4]); %coordinates play different roles
        case 4 %BCD, 't'
        p2x2=outprod(pu,ptg); %works for BCD: pu ia A, pg is BCD
    end
    cgs_aug=mtc_probs2cgs(p2x2,mtcs);
    vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
    mname='Pickard';
end
if (n2hv==1) & (n3==1) %cgsstruct_each(1) is theta, cgsstruct_each(2) beta_hv
    %
    %this is always Pickard, create a structure with other low-order coords
    %zero and then maximize entropy for high-order param
    %
    %merge the theta and beta into a structure
    [cgsaug_struct,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
        =mtc_cgsstruct_merge(cgsstruct_each{1},cgsstruct_each{2},setfield(aug_opts,'mismatch_action','error'));
    if (aug_opts.iflog==1)
        disp(mergemsg_all);
    end
    cgs_struct_loworder=mtc_cgsstruct_remove(cgsaug_struct,mtcs.nchecks,mtcs,mtcs.counts);
    %maximize the entropy across high-order params
    opts_me=aug_opts.me_opts;
    opts_me.cgshint_struct=[]; %start assuming alpha=0
    [cgs_vals_maxentropy,cgs_vals_loworder,cgs_list,opts_used_me]=mtc_cgsstruct2cgs_me(cgs_struct_loworder,mtcs,opts_me);
    cgs_aug=cgs_vals_maxentropy;
    vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
    mname='Pickard';
end
if (n2di==1) & (n3==1) %cgsstruct_each(1) is theta, cgsstruct_each(2) beta_di
    if all((dict.inpickard(:,btc_coordnum(1))==dict.inpickard(:,btc_coordnum(2))))
        %case in which the checks correlated by the diagonal beta is included in the checks of the theta
        %
        %this is always Pickard, create a structure by merging coords, setting others to zero
        %merge the theta and beta into a structure
        [cgsaug_struct,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
            =mtc_cgsstruct_merge(cgsstruct_each{1},cgsstruct_each{2},setfield(aug_opts,'mismatch_action','error'));
        cgs_aug=mtc_cgsstruct2cgs(cgsaug_struct,mtcs);
        vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
        mname='Pickard';
    else
    %case in which the checks correlated by the diagonal beta is ARE NOT in the checks of the theta
    %do this by Metropolis, seeding with random other than diagonal beta,
    %enforcing gamma=0 and h,v betas=0 by swapping algorithm
    %
    % First do a merge, then rotate, then do a Markov combination
        [merge_struct,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
            =mtc_cgsstruct_merge(cgsstruct_each{1},cgsstruct_each{2},setfield(aug_opts,'mismatch_action','error'));
        if (aug_opts.iflog==1)
            disp(mergemsg_all);
        end
        if (btc_coordposit(1)==1) & (btc_coordposit(2)==3) %v, d
            prot_bt=[1 2 3 4];
            vnums=1;
        end
        if (btc_coordposit(1)==3) & (btc_coordposit(2)==4) %u, e
            prot_bt=[3 1 4 2];
            vnums=2;
        end
        if (btc_coordposit(1)==4) & (btc_coordposit(2)==3) %t, d
            prot_bt=[4 3 2 1];
            vnums=3;
        end
        if (btc_coordposit(1)==2) & (btc_coordposit(2)==4) %w, e
            vnums=4;
            prot_bt=[2 4 1 3];
        end
        p2x2_merge=mtc_cgss2probs(mtc_cgsstruct2cgs(merge_struct,mtcs),mtcs);
        %rotate into standard position, which here is v,d
        p2x2_merge_r=permute(p2x2_merge,prot_bt);
        merge_struct_r_clean=mtc_cgsstruct_clean(mtc_cgs2cgsstruct(mtc_probs2cgs(p2x2_merge_r,mtcs),mtcs),mtcs);
        %do the Markov calculation p(ABCD)=p(AD)p(ABC)/p(A), using p(A)=1/ng
        pDA=(squeeze(sum(sum(p2x2_merge_r,3),2)))';
        pABC=sum(p2x2_merge_r,4);
        pDABC=ng*outprod_contract(pDA,pABC,[1 2]');
        p2x2_aug_r=permute(pDABC,[2 3 4 1]); %this is pABCD
        %corrs=setfield(corrs,name3,{5-btc_coordposit(1)},cgsstruct_each(1)*cgsstruct_each(2)); %the opposite theta is beta*theta
        cgs_aug_r=mtc_probs2cgs(p2x2_aug_r,mtcs);
        cgsaug_struct_r=mtc_cgs2cgsstruct(cgs_aug_r,mtcs);
        cgsaug_struct_r_clean=mtc_cgsstruct_clean(cgsaug_struct_r,mtcs);
        %
        prot_bt_inv(prot_bt)=[1:4]; %the permutation to rotate back
        p2x2_aug=permute(p2x2_aug_r,prot_bt_inv);
        cgs_aug=mtc_probs2cgs(p2x2_aug,mtcs);
        cgsaug_struct_clean=mtc_cgsstruct_clean(mtc_cgs2cgsstruct(cgs_aug,mtcs),mtcs);       
        if (aug_opts.iflog==1)
            disp('mtc_augcoords:  merged   structure for nonPickard beta-theta, unrotated:')
            disp(merge_struct);
            disp('mtc_augcoords:  merged   structure for nonPickard beta-theta, rotated, cleaned:')
            disp(merge_struct_r_clean);
            disp('mtc_augcoords:  augmented structure for nonPickard beta-theta, rotated into (v,d), cleaned:')
            disp(cgsaug_struct_r_clean);
            disp('mtc_augcoords:  augmented structure for nonPickard beta-theta, unrotated, cleaned:')
            disp(cgsaug_struct_clean);
        end
        %
        %now put into a "tee" structure
        % as 2x2    as tee
        % A B       A B E
        % C D         D
        % The 2x2 should have AD, ABC, and also BCD (corresponding to beta*theta),
        % and ABCD (for ng>=3). 
        % AD in 2x2 maps to AD in tee; ABC in 2x2 maps to BED in tee
        % BCD and ABCD are not included in tee.
        %
        %
        mtcs_tee=mtc_define(ng,gtc_define([0 0;0 1;0 2;1 1]));
        tee_struct_r=[];
        cgsnames=fieldnames(cgsaug_struct_r_clean);
        for iname=1:length(cgsnames)
            fn=cgsnames{iname};
            if strmatch('AD_',fn)
                tee_struct_r.(fn)=cgsaug_struct_r_clean.(fn);
            end
            if strmatch('ABC_',fn)
                tee_struct_r.(strrep(fn,'ABC_','BED_'))=cgsaug_struct_r_clean.(fn);
            end
        end
        % add ABE corresponding to (AD)^2*theta_ABC (V&C, JOSA 2012)
        %determine pABE by first calculating
        % A B
        % C D F
        % and then marginalizing over A, B
        pACDBF=ng*outprod_contract(p2x2_aug_r,pDA',[2 1]'); %p2x2_aug_r=pABCD, pDA'=pAD=pBF
        pABCDF=permute(pACDBF,[1 4 2 3 5]);
        pCDF=squeeze(sum(sum(pABCDF,2),1));
        mtcs_1x3=mtc_define(ng,gtc_define([0 0;0 1;0 2]));
        CDF_struct_r=mtc_cgs2cgsstruct(mtc_probs2cgs(pCDF,mtcs_1x3),mtcs_1x3);
        CDF_struct_r_clean=mtc_cgsstruct_clean(CDF_struct_r,mtcs_1x3);
        %
        cgsnames_1x3=fieldnames(CDF_struct_r_clean);
        for iname=1:length(cgsnames_1x3)
            fn=cgsnames_1x3{iname};
            if strmatch('ABE_',fn)
                tee_struct_r.(fn)=CDF_struct_r.(fn);
            end
        end
        if (aug_opts.iflog==1)
            disp('mtc_augcoords: augmented structure for 1x3 correlations, rotated:')
            disp(CDF_struct_r);
            disp('mtc_augcoords: augmented structure for 1x3 correlations, rotated, cleaned:')
            disp(CDF_struct_r_clean);
            disp('mtc_augcoords: tee structure, rotated:')
            disp(tee_struct_r);
        end
        extend.cgsaug_struct_r=cgsaug_struct_r;
        extend.tee_struct_r=tee_struct_r;
        extend.tee_probs_r=mtc_cgss2probs(mtc_cgsstruct2cgs(tee_struct_r,mtcs_tee),mtcs_tee);
        mname='NoPickBT';
    end
end
if (n3==2) %cgsstruct_each(1) and cgsstruct_each(2) are thetas
    if all((dict.inpickard(:,btc_coordnum(1))==dict.inpickard(:,btc_coordnum(2)))) %this is tv and uw
        %case in which the thetas share a common corner (Pickard)
        %this is always Pickard, create a structure by merging coords, setting others to zero
        [cgsaug_struct,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
            =mtc_cgsstruct_merge(cgsstruct_each{1},cgsstruct_each{2},setfield(aug_opts,'mismatch_action','error'));
        if (aug_opts.iflog==1)
            disp(mergemsg_all);
        end
        cgs_aug=mtc_cgsstruct2cgs(cgsaug_struct,mtcs);
        vnums=find(dict.inpickard(:,btc_coordnum(1))==1);
        mname='Pickard';
    else
    %case in which the thetas share a common edge: tu, uv, vw, tw
    %do this by Metropolis, enforcing betas and gammas=0 by swapping algorithm
        [cgsaug_struct,merge_counts,mergemsg_warn,mergemsg_all,merge_ou]...
            =mtc_cgsstruct_merge(cgsstruct_each{1},cgsstruct_each{2},setfield(aug_opts,'mismatch_action','error'));
        cgs_aug=mtc_cgsstruct2cgs(cgsaug_struct,mtcs);
        if (aug_opts.iflog==1)
            disp(mergemsg_all);
        end
        if (length(intersect(btc_coordposit,[3 4])))==2 %t, u
            vnums=1;
        end
        if (length(intersect(btc_coordposit,[2 4])))==2 %t, w
            vnums=2;
        end
        if (length(intersect(btc_coordposit,[1 2])))==2 %v, w
            vnums=3;
        end
        if (length(intersect(btc_coordposit,[1 3])))==2 %u, v
            vnums=4;
        end
        mname='NoPickTT';
    end
end
return
function [cgs_parsed,letcodes,exptname,nspec]=mtc_augcoords_setup(cgs_struct,dict,mtcs,remove_checks)
%
%set up a cgs_parsed structure, possibly removing coordinates whose checks are specified by 'remove_check'
%  e.g., set remove_check to 'ABCD' to remove any coordinates involving alpha
%
if (nargin<=3)
    remove_checks=[];
end
coord_groups_used=fieldnames(cgs_struct);
cgs_struct_r=[];
%
letcodes=[];
checks=cell(0);
cgs_byletcode=[];
iax=0;
for iaxa=1:length(coord_groups_used)
    dashpos= min(find(coord_groups_used{iaxa}=='_'));
    check_test=coord_groups_used{iaxa}(1:dashpos-1);
    if ~strcmp(check_test,remove_checks)
        iax=iax+1;        
        checks_temp=coord_groups_used{iaxa}(1:dashpos-1); %these checks are in the order of the cgs structure, not experiment order
        letcodes(iax)=mtcs.codel(strmatch(checks_temp,mtcs.checks,'exact'));
        if ~isfield(cgs_byletcode,char(letcodes(iax)))
            cgs_byletcode.(char(letcodes(iax)))=[];
        end
        cgs_byletcode.(char(letcodes(iax))).(coord_groups_used{iaxa})=cgs_struct.(coord_groups_used{iaxa});
        cgs_struct_r.(coord_groups_used{iaxa})=cgs_struct.(coord_groups_used{iaxa});
    end
end
letcodes=char(letcodes);
exptname=btc_exptname(letcodes,dict);
%now create a set of checks that are in experiment order
for iax=1:length(exptname)
    checks{iax}=dict.checks{find(dict.codel==exptname(iax))};
end
nspec=length(exptname);
%this indicates which kinds of btc coordinates are present 
coorkinds_letcodes=btc_coorkinds(letcodes,dict); %if the same letter is used twice in cgs_struct, it will be duplicated here
coorkinds=btc_coorkinds(exptname,dict); %this removes duplicates
%
name1=dict.ordernames{1};
name2=dict.ordernames{2};
name2hv=cat(2,dict.ordernames{2},'_hv');
name2di=cat(2,dict.ordernames{2},'_diag');
name3=dict.ordernames{3};
name4=dict.ordernames{4};
%
n1=length(getfield(coorkinds,name1));
n2hv=length(getfield(coorkinds,name2hv));
n2di=length(getfield(coorkinds,name2di));
n3=length(getfield(coorkinds,name3));
n4=length(getfield(coorkinds,name4));
nkinds=[n1 n2hv+n2di n3 n4];
%
btc_coordnum=[];
btc_coordposit=[];
for q=1:length(exptname)
    btc_coordnum(q)=find(dict.codel==exptname(q));
    btc_coordposit(q)=dict.posit(btc_coordnum(q));
end
%
cgs_parsed=[];
cgs_parsed.cgs_struct=cgs_struct_r;
cgs_parsed.checks=checks;
cgs_parsed.letcodes=letcodes;
cgs_parsed.coorkinds=coorkinds;
cgs_parsed.exptname=exptname;
cgs_parsed.nspec=nspec;
cgs_parsed.nkinds=nkinds;
cgs_parsed.btc_coordnum=btc_coordnum;
cgs_parsed.btc_coordposit=btc_coordposit;
cgs_parsed.cgs_byletcode=cgs_byletcode;
%
return

function [cgs_aug_ok,vnums_ok,mname_ok]=mtc_augcoords_nonneg(cgs_aug,vnums,mname,mtcs,aug_opts);
% remove the values of cgs_aug, vnums, and mname that correspond to probabilities that are non-negative
%
cgs_aug_ok=[];
vnums_ok=[];
mname_ok=[];
if iscell(cgs_aug)
    cout=0;
    for cin=1:length(vnums)
        p2x2=mtc_cgsstruct2cgs(cgs_aug{cin},mtcs);
        if min(p2x2(:))>(-aug_opts.tol_nonneg)
            cout=cout+1;
            cgs_aug_ok{1,cout}=cgs_aug{cin};
            vnums_ok(1,cout)=vnums(1,cin);
            if iscell(mname)
                mname_ok{1,cout}=mname{1,cin};
            else
                mname_ok=mname;
            end
        end
    end
else %cgs_aug is not a cell, so it is a single value that only needs to be checked once
    p2x2=mtc_cgst2probs(cgs_aug,mtcs);
    if min(p2x2(:))>(-aug_opts.tol_nonneg)
        cgs_aug_ok=cgs_aug;
        vnums_ok=vnums;
        mname_ok=mname;
    end
end
return


